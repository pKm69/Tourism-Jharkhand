{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/lib/ai-services.ts"],"sourcesContent":["// Advanced AI Services for Tourism Jharkhand\r\n// Integrates multiple AI APIs for comprehensive analysis\r\n\r\nexport interface AIAnalysisResult {\r\n  sentiment: 'positive' | 'negative' | 'neutral'\r\n  confidence: number\r\n  emotions: { [key: string]: number }\r\n  keywords: string[]\r\n  language: string\r\n  toxicity?: number\r\n  urgency?: 'low' | 'medium' | 'high' | 'critical'\r\n  categories?: string[]\r\n  actionableInsights?: string[]\r\n}\r\n\r\nexport interface VoiceAnalysisResult {\r\n  transcription: string\r\n  sentiment: 'positive' | 'negative' | 'neutral'\r\n  confidence: number\r\n  emotions: { [key: string]: number }\r\n  speakerTone: 'calm' | 'excited' | 'frustrated' | 'angry' | 'happy'\r\n  language: string\r\n}\r\n\r\nexport interface ImageAnalysisResult {\r\n  description: string\r\n  objects: string[]\r\n  sentiment: 'positive' | 'negative' | 'neutral'\r\n  quality: number\r\n  issues?: string[]\r\n  location?: string\r\n}\r\n\r\n// Advanced multilingual sentiment analysis with multiple AI models\r\nexport class AdvancedAIService {\r\n  private huggingFaceKey: string\r\n  private openAIKey?: string\r\n  private googleCloudKey?: string\r\n\r\n  constructor() {\r\n    this.huggingFaceKey = process.env.HUGGINGFACE_API_KEY || ''\r\n    this.openAIKey = process.env.OPENAI_API_KEY\r\n    this.googleCloudKey = process.env.GOOGLE_CLOUD_API_KEY\r\n  }\r\n\r\n  // Enhanced text analysis with multiple AI models\r\n  async analyzeText(text: string, language: string = 'auto'): Promise<AIAnalysisResult> {\r\n    try {\r\n      // Detect language if not specified\r\n      const detectedLanguage = language === 'auto' ? await this.detectLanguage(text) : language\r\n\r\n      // Run multiple AI analyses in parallel\r\n      const [sentimentResult, emotionResult, toxicityResult, categoryResult] = await Promise.allSettled([\r\n        this.analyzeSentiment(text, detectedLanguage),\r\n        this.analyzeEmotions(text),\r\n        this.analyzeToxicity(text),\r\n        this.categorizeText(text)\r\n      ])\r\n\r\n      // Extract keywords using advanced NLP\r\n      const keywords = await this.extractAdvancedKeywords(text, detectedLanguage)\r\n\r\n      // Generate actionable insights\r\n      const insights = await this.generateActionableInsights(text, detectedLanguage)\r\n\r\n      // Determine urgency level\r\n      const urgency = this.calculateUrgency(\r\n        sentimentResult.status === 'fulfilled' ? sentimentResult.value : null,\r\n        toxicityResult.status === 'fulfilled' ? toxicityResult.value : 0\r\n      )\r\n\r\n      return {\r\n        sentiment: sentimentResult.status === 'fulfilled' ? sentimentResult.value.sentiment : 'neutral',\r\n        confidence: sentimentResult.status === 'fulfilled' ? sentimentResult.value.confidence : 0.5,\r\n        emotions: emotionResult.status === 'fulfilled' ? emotionResult.value : {},\r\n        keywords,\r\n        language: detectedLanguage,\r\n        toxicity: toxicityResult.status === 'fulfilled' ? toxicityResult.value : 0,\r\n        urgency,\r\n        categories: categoryResult.status === 'fulfilled' ? categoryResult.value : [],\r\n        actionableInsights: insights\r\n      }\r\n    } catch (error) {\r\n      console.error('Advanced AI analysis failed:', error)\r\n      return this.fallbackAnalysis(text, language)\r\n    }\r\n  }\r\n\r\n  // Voice analysis with speech-to-text and emotion detection\r\n  async analyzeVoice(audioBlob: Blob): Promise<VoiceAnalysisResult> {\r\n    try {\r\n      // Convert audio to text using Hugging Face Whisper\r\n      const transcription = await this.speechToText(audioBlob)\r\n      \r\n      // Analyze the transcribed text\r\n      const textAnalysis = await this.analyzeText(transcription)\r\n      \r\n      // Analyze voice tone and emotions from audio\r\n      const voiceEmotions = await this.analyzeVoiceEmotions(audioBlob)\r\n      \r\n      return {\r\n        transcription,\r\n        sentiment: textAnalysis.sentiment,\r\n        confidence: textAnalysis.confidence,\r\n        emotions: { ...textAnalysis.emotions, ...voiceEmotions },\r\n        speakerTone: this.determineSpeakerTone(voiceEmotions),\r\n        language: textAnalysis.language\r\n      }\r\n    } catch (error) {\r\n      console.error('Voice analysis failed:', error)\r\n      throw new Error('Voice analysis service unavailable')\r\n    }\r\n  }\r\n\r\n  // Image analysis for visual feedback\r\n  async analyzeImage(imageBlob: Blob): Promise<ImageAnalysisResult> {\r\n    try {\r\n      // Convert image to base64\r\n      const base64Image = await this.blobToBase64(imageBlob)\r\n      \r\n      // Analyze image content using Hugging Face Vision models\r\n      const [description, objects, sentiment] = await Promise.all([\r\n        this.generateImageDescription(base64Image),\r\n        this.detectObjects(base64Image),\r\n        this.analyzeImageSentiment(base64Image)\r\n      ])\r\n\r\n      // Assess image quality\r\n      const quality = await this.assessImageQuality(base64Image)\r\n      \r\n      // Detect potential issues\r\n      const issues = await this.detectImageIssues(base64Image, objects)\r\n\r\n      return {\r\n        description,\r\n        objects,\r\n        sentiment,\r\n        quality,\r\n        issues,\r\n        location: await this.extractLocationFromImage(base64Image)\r\n      }\r\n    } catch (error) {\r\n      console.error('Image analysis failed:', error)\r\n      throw new Error('Image analysis service unavailable')\r\n    }\r\n  }\r\n\r\n  // Language detection using AI\r\n  private async detectLanguage(text: string): Promise<string> {\r\n    try {\r\n      const response = await fetch(\r\n        'https://api-inference.huggingface.co/models/facebook/fasttext-language-identification',\r\n        {\r\n          headers: {\r\n            'Authorization': `Bearer ${this.huggingFaceKey}`,\r\n            'Content-Type': 'application/json',\r\n          },\r\n          method: 'POST',\r\n          body: JSON.stringify({ inputs: text }),\r\n        }\r\n      )\r\n\r\n      if (response.ok) {\r\n        const result = await response.json()\r\n        return result[0]?.label?.replace('__label__', '') || 'en'\r\n      }\r\n    } catch (error) {\r\n      console.error('Language detection failed:', error)\r\n    }\r\n    return 'en'\r\n  }\r\n\r\n  // Enhanced sentiment analysis with multiple models\r\n  private async analyzeSentiment(text: string, language: string): Promise<{sentiment: string, confidence: number}> {\r\n    const models = [\r\n      'cardiffnlp/twitter-roberta-base-sentiment-latest',\r\n      'nlptown/bert-base-multilingual-uncased-sentiment'\r\n    ]\r\n\r\n    for (const model of models) {\r\n      try {\r\n        const response = await fetch(\r\n          `https://api-inference.huggingface.co/models/${model}`,\r\n          {\r\n            headers: {\r\n              'Authorization': `Bearer ${this.huggingFaceKey}`,\r\n              'Content-Type': 'application/json',\r\n            },\r\n            method: 'POST',\r\n            body: JSON.stringify({ inputs: text }),\r\n          }\r\n        )\r\n\r\n        if (response.ok) {\r\n          const result = await response.json()\r\n          if (Array.isArray(result) && result.length > 0) {\r\n            const topResult = result[0]\r\n            return {\r\n              sentiment: this.normalizeSentiment(topResult.label),\r\n              confidence: topResult.score\r\n            }\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error(`Sentiment analysis with ${model} failed:`, error)\r\n      }\r\n    }\r\n\r\n    throw new Error('All sentiment analysis models failed')\r\n  }\r\n\r\n  // Advanced emotion analysis\r\n  private async analyzeEmotions(text: string): Promise<{ [key: string]: number }> {\r\n    try {\r\n      const response = await fetch(\r\n        'https://api-inference.huggingface.co/models/j-hartmann/emotion-english-distilroberta-base',\r\n        {\r\n          headers: {\r\n            'Authorization': `Bearer ${this.huggingFaceKey}`,\r\n            'Content-Type': 'application/json',\r\n          },\r\n          method: 'POST',\r\n          body: JSON.stringify({ inputs: text }),\r\n        }\r\n      )\r\n\r\n      if (response.ok) {\r\n        const emotions = await response.json()\r\n        if (Array.isArray(emotions) && emotions.length > 0) {\r\n          const emotionScores: { [key: string]: number } = {}\r\n          emotions[0].forEach((emotion: any) => {\r\n            emotionScores[emotion.label.toLowerCase()] = emotion.score\r\n          })\r\n          return emotionScores\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Emotion analysis failed:', error)\r\n    }\r\n    return {}\r\n  }\r\n\r\n  // Toxicity detection\r\n  private async analyzeToxicity(text: string): Promise<number> {\r\n    try {\r\n      const response = await fetch(\r\n        'https://api-inference.huggingface.co/models/unitary/toxic-bert',\r\n        {\r\n          headers: {\r\n            'Authorization': `Bearer ${this.huggingFaceKey}`,\r\n            'Content-Type': 'application/json',\r\n          },\r\n          method: 'POST',\r\n          body: JSON.stringify({ inputs: text }),\r\n        }\r\n      )\r\n\r\n      if (response.ok) {\r\n        const result = await response.json()\r\n        if (Array.isArray(result) && result.length > 0) {\r\n          const toxicResult = result[0].find((r: any) => r.label === 'TOXIC')\r\n          return toxicResult ? toxicResult.score : 0\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Toxicity analysis failed:', error)\r\n    }\r\n    return 0\r\n  }\r\n\r\n  // Text categorization\r\n  private async categorizeText(text: string): Promise<string[]> {\r\n    try {\r\n      const response = await fetch(\r\n        'https://api-inference.huggingface.co/models/facebook/bart-large-mnli',\r\n        {\r\n          headers: {\r\n            'Authorization': `Bearer ${this.huggingFaceKey}`,\r\n            'Content-Type': 'application/json',\r\n          },\r\n          method: 'POST',\r\n          body: JSON.stringify({\r\n            inputs: text,\r\n            parameters: {\r\n              candidate_labels: [\r\n                'accommodation', 'food', 'transportation', 'attractions', \r\n                'service quality', 'cleanliness', 'safety', 'pricing', \r\n                'accessibility', 'cultural experience'\r\n              ]\r\n            }\r\n          }),\r\n        }\r\n      )\r\n\r\n      if (response.ok) {\r\n        const result = await response.json()\r\n        return result.labels?.slice(0, 3) || []\r\n      }\r\n    } catch (error) {\r\n      console.error('Text categorization failed:', error)\r\n    }\r\n    return []\r\n  }\r\n\r\n  // Advanced keyword extraction using TF-IDF and NER\r\n  private async extractAdvancedKeywords(text: string, language: string): Promise<string[]> {\r\n    try {\r\n      // Named Entity Recognition\r\n      const response = await fetch(\r\n        'https://api-inference.huggingface.co/models/dbmdz/bert-large-cased-finetuned-conll03-english',\r\n        {\r\n          headers: {\r\n            'Authorization': `Bearer ${this.huggingFaceKey}`,\r\n            'Content-Type': 'application/json',\r\n          },\r\n          method: 'POST',\r\n          body: JSON.stringify({ inputs: text }),\r\n        }\r\n      )\r\n\r\n      const entities: string[] = []\r\n      if (response.ok) {\r\n        const result = await response.json()\r\n        if (Array.isArray(result)) {\r\n          result.forEach((entity: any) => {\r\n            if (entity.entity_group && entity.word) {\r\n              entities.push(entity.word.replace('##', ''))\r\n            }\r\n          })\r\n        }\r\n      }\r\n\r\n      // Combine with TF-IDF keywords\r\n      const tfidfKeywords = this.extractTFIDFKeywords(text)\r\n      \r\n      return [...new Set([...entities, ...tfidfKeywords])].slice(0, 10)\r\n    } catch (error) {\r\n      console.error('Advanced keyword extraction failed:', error)\r\n      return this.extractTFIDFKeywords(text)\r\n    }\r\n  }\r\n\r\n  // Generate actionable insights using AI\r\n  private async generateActionableInsights(text: string, language: string): Promise<string[]> {\r\n    const insights: string[] = []\r\n    \r\n    // Rule-based insights for now (can be enhanced with GPT-4 later)\r\n    const lowercaseText = text.toLowerCase()\r\n    \r\n    if (lowercaseText.includes('dirty') || lowercaseText.includes('unclean')) {\r\n      insights.push('Immediate cleaning and hygiene improvement required')\r\n    }\r\n    \r\n    if (lowercaseText.includes('expensive') || lowercaseText.includes('overpriced')) {\r\n      insights.push('Review pricing strategy and provide value justification')\r\n    }\r\n    \r\n    if (lowercaseText.includes('rude') || lowercaseText.includes('unprofessional')) {\r\n      insights.push('Staff training and customer service improvement needed')\r\n    }\r\n    \r\n    if (lowercaseText.includes('unsafe') || lowercaseText.includes('dangerous')) {\r\n      insights.push('URGENT: Safety assessment and security measures required')\r\n    }\r\n    \r\n    if (lowercaseText.includes('beautiful') || lowercaseText.includes('amazing')) {\r\n      insights.push('Leverage positive aspects in marketing and promotion')\r\n    }\r\n\r\n    return insights\r\n  }\r\n\r\n  // Calculate urgency level\r\n  private calculateUrgency(sentiment: any, toxicity: number): 'low' | 'medium' | 'high' | 'critical' {\r\n    if (toxicity > 0.8 || (sentiment?.sentiment === 'negative' && sentiment?.confidence > 0.9)) {\r\n      return 'critical'\r\n    }\r\n    if (toxicity > 0.6 || (sentiment?.sentiment === 'negative' && sentiment?.confidence > 0.7)) {\r\n      return 'high'\r\n    }\r\n    if (toxicity > 0.3 || (sentiment?.sentiment === 'negative' && sentiment?.confidence > 0.5)) {\r\n      return 'medium'\r\n    }\r\n    return 'low'\r\n  }\r\n\r\n  // Speech to text conversion\r\n  private async speechToText(audioBlob: Blob): Promise<string> {\r\n    try {\r\n      const formData = new FormData()\r\n      formData.append('file', audioBlob, 'audio.wav')\r\n\r\n      const response = await fetch(\r\n        'https://api-inference.huggingface.co/models/openai/whisper-large-v3',\r\n        {\r\n          headers: {\r\n            'Authorization': `Bearer ${this.huggingFaceKey}`,\r\n          },\r\n          method: 'POST',\r\n          body: formData,\r\n        }\r\n      )\r\n\r\n      if (response.ok) {\r\n        const result = await response.json()\r\n        return result.text || ''\r\n      }\r\n    } catch (error) {\r\n      console.error('Speech to text failed:', error)\r\n    }\r\n    return ''\r\n  }\r\n\r\n  // Voice emotion analysis\r\n  private async analyzeVoiceEmotions(audioBlob: Blob): Promise<{ [key: string]: number }> {\r\n    // Placeholder for voice emotion analysis\r\n    // In production, this would use specialized audio emotion recognition models\r\n    return {\r\n      calm: 0.3,\r\n      excited: 0.2,\r\n      frustrated: 0.1,\r\n      happy: 0.4\r\n    }\r\n  }\r\n\r\n  // Determine speaker tone from voice emotions\r\n  private determineSpeakerTone(emotions: { [key: string]: number }): 'calm' | 'excited' | 'frustrated' | 'angry' | 'happy' {\r\n    const maxEmotion = Object.entries(emotions).reduce((a, b) => a[1] > b[1] ? a : b)\r\n    return maxEmotion[0] as any || 'calm'\r\n  }\r\n\r\n  // Image description generation\r\n  private async generateImageDescription(base64Image: string): Promise<string> {\r\n    try {\r\n      const response = await fetch(\r\n        'https://api-inference.huggingface.co/models/Salesforce/blip-image-captioning-large',\r\n        {\r\n          headers: {\r\n            'Authorization': `Bearer ${this.huggingFaceKey}`,\r\n            'Content-Type': 'application/json',\r\n          },\r\n          method: 'POST',\r\n          body: JSON.stringify({ inputs: base64Image }),\r\n        }\r\n      )\r\n\r\n      if (response.ok) {\r\n        const result = await response.json()\r\n        return result[0]?.generated_text || 'Unable to generate description'\r\n      }\r\n    } catch (error) {\r\n      console.error('Image description failed:', error)\r\n    }\r\n    return 'Image analysis unavailable'\r\n  }\r\n\r\n  // Object detection in images\r\n  private async detectObjects(base64Image: string): Promise<string[]> {\r\n    try {\r\n      const response = await fetch(\r\n        'https://api-inference.huggingface.co/models/facebook/detr-resnet-50',\r\n        {\r\n          headers: {\r\n            'Authorization': `Bearer ${this.huggingFaceKey}`,\r\n            'Content-Type': 'application/json',\r\n          },\r\n          method: 'POST',\r\n          body: JSON.stringify({ inputs: base64Image }),\r\n        }\r\n      )\r\n\r\n      if (response.ok) {\r\n        const result = await response.json()\r\n        return result.map((obj: any) => obj.label).slice(0, 10)\r\n      }\r\n    } catch (error) {\r\n      console.error('Object detection failed:', error)\r\n    }\r\n    return []\r\n  }\r\n\r\n  // Image sentiment analysis\r\n  private async analyzeImageSentiment(base64Image: string): Promise<'positive' | 'negative' | 'neutral'> {\r\n    // Placeholder - would use specialized image sentiment models\r\n    return 'neutral'\r\n  }\r\n\r\n  // Assess image quality\r\n  private async assessImageQuality(base64Image: string): Promise<number> {\r\n    // Placeholder - would use image quality assessment models\r\n    return Math.random() * 0.3 + 0.7 // Random quality between 0.7-1.0\r\n  }\r\n\r\n  // Detect issues in images\r\n  private async detectImageIssues(base64Image: string, objects: string[]): Promise<string[]> {\r\n    const issues: string[] = []\r\n    \r\n    // Rule-based issue detection\r\n    if (objects.includes('trash') || objects.includes('garbage')) {\r\n      issues.push('Cleanliness issue detected')\r\n    }\r\n    \r\n    if (objects.includes('damage') || objects.includes('broken')) {\r\n      issues.push('Infrastructure damage detected')\r\n    }\r\n    \r\n    return issues\r\n  }\r\n\r\n  // Extract location from image metadata\r\n  private async extractLocationFromImage(base64Image: string): Promise<string | undefined> {\r\n    // Placeholder - would extract GPS data from EXIF or use image recognition\r\n    return undefined\r\n  }\r\n\r\n  // Utility functions\r\n  private async blobToBase64(blob: Blob): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n      const reader = new FileReader()\r\n      reader.onloadend = () => resolve(reader.result as string)\r\n      reader.onerror = reject\r\n      reader.readAsDataURL(blob)\r\n    })\r\n  }\r\n\r\n  private normalizeSentiment(label: string): 'positive' | 'negative' | 'neutral' {\r\n    const normalized = label.toLowerCase()\r\n    if (normalized.includes('positive') || normalized.includes('pos')) return 'positive'\r\n    if (normalized.includes('negative') || normalized.includes('neg')) return 'negative'\r\n    return 'neutral'\r\n  }\r\n\r\n  private extractTFIDFKeywords(text: string): string[] {\r\n    const stopWords = new Set([\r\n      'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by',\r\n      'is', 'was', 'are', 'were', 'be', 'been', 'have', 'has', 'had', 'do', 'does', 'did',\r\n      'will', 'would', 'could', 'should', 'may', 'might', 'must', 'can', 'this', 'that',\r\n      'these', 'those', 'i', 'you', 'he', 'she', 'it', 'we', 'they', 'me', 'him', 'her', 'us', 'them'\r\n    ])\r\n    \r\n    const words = text.toLowerCase()\r\n      .replace(/[^\\w\\s]/g, '')\r\n      .split(/\\s+/)\r\n      .filter(word => word.length > 2 && !stopWords.has(word))\r\n    \r\n    const wordCount: { [key: string]: number } = {}\r\n    words.forEach(word => {\r\n      wordCount[word] = (wordCount[word] || 0) + 1\r\n    })\r\n    \r\n    return Object.entries(wordCount)\r\n      .sort(([,a], [,b]) => b - a)\r\n      .slice(0, 5)\r\n      .map(([word]) => word)\r\n  }\r\n\r\n  private fallbackAnalysis(text: string, language: string): AIAnalysisResult {\r\n    // Simple rule-based fallback\r\n    const positiveWords = ['good', 'great', 'excellent', 'amazing', 'wonderful', 'beautiful', 'love', 'perfect']\r\n    const negativeWords = ['bad', 'terrible', 'awful', 'horrible', 'hate', 'worst', 'disappointing', 'poor']\r\n    \r\n    const words = text.toLowerCase().split(/\\s+/)\r\n    const positiveCount = words.filter(word => positiveWords.includes(word)).length\r\n    const negativeCount = words.filter(word => negativeWords.includes(word)).length\r\n    \r\n    let sentiment: 'positive' | 'negative' | 'neutral' = 'neutral'\r\n    let confidence = 0.5\r\n    \r\n    if (positiveCount > negativeCount) {\r\n      sentiment = 'positive'\r\n      confidence = Math.min(0.8, 0.5 + (positiveCount - negativeCount) * 0.1)\r\n    } else if (negativeCount > positiveCount) {\r\n      sentiment = 'negative'\r\n      confidence = Math.min(0.8, 0.5 + (negativeCount - positiveCount) * 0.1)\r\n    }\r\n    \r\n    return {\r\n      sentiment,\r\n      confidence,\r\n      emotions: {\r\n        joy: sentiment === 'positive' ? confidence * 0.8 : 0.1,\r\n        anger: sentiment === 'negative' ? confidence * 0.6 : 0.1,\r\n        sadness: sentiment === 'negative' ? confidence * 0.4 : 0.1,\r\n      },\r\n      keywords: this.extractTFIDFKeywords(text),\r\n      language: language || 'en',\r\n      toxicity: 0,\r\n      urgency: 'low',\r\n      categories: [],\r\n      actionableInsights: []\r\n    }\r\n  }\r\n}\r\n\r\n// Singleton instance\r\nexport const aiService = new AdvancedAIService()\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 561, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 566, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/app/api/feedback/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\r\nimport { aiService, AIAnalysisResult, VoiceAnalysisResult, ImageAnalysisResult } from '@/lib/ai-services'\r\n\r\n// Enhanced feedback interface\r\ninterface EnhancedFeedback {\r\n  id: number\r\n  userId: string\r\n  userName: string\r\n  location: string\r\n  category: string\r\n  rating: number\r\n  textFeedback?: string\r\n  language: string\r\n  voiceData?: string\r\n  imageData?: string\r\n  emojiRating?: string\r\n  aiAnalysis: AIAnalysisResult\r\n  voiceAnalysis?: VoiceAnalysisResult\r\n  imageAnalysis?: ImageAnalysisResult\r\n  timestamp: string\r\n  isVerified: boolean\r\n  responseFromVendor?: string\r\n  flagged: boolean\r\n  urgencyLevel: 'low' | 'medium' | 'high' | 'critical'\r\n  autoResponseGenerated?: string\r\n  escalated?: boolean\r\n  resolvedAt?: string\r\n  satisfactionFollowUp?: number\r\n}\r\n\r\n// Real-time alert system\r\nclass AlertSystem {\r\n  static async triggerAlert(feedback: EnhancedFeedback) {\r\n    if (feedback.urgencyLevel === 'critical' || feedback.urgencyLevel === 'high') {\r\n      // In production, this would send real notifications\r\n      console.log(`ðŸš¨ CRITICAL ALERT: ${feedback.location} - ${feedback.category}`);\r\n      console.log(`Issue: ${feedback.aiAnalysis.actionableInsights?.join(', ')}`);\r\n      \r\n      // Auto-generate response for critical issues\r\n      feedback.autoResponseGenerated = await this.generateAutoResponse(feedback);\r\n      feedback.escalated = true;\r\n    }\r\n  }\r\n\r\n  static async generateAutoResponse(feedback: EnhancedFeedback): Promise<string> {\r\n    const insights = feedback.aiAnalysis.actionableInsights || [];\r\n    \r\n    if (insights.some(i => i.includes('URGENT') || i.includes('Safety'))) {\r\n      return `Thank you for bringing this safety concern to our attention. We have immediately escalated this issue to our safety team and will address it within 24 hours. Your safety is our top priority.`;\r\n    }\r\n    \r\n    if (feedback.aiAnalysis.sentiment === 'negative' && feedback.aiAnalysis.confidence > 0.8) {\r\n      return `We sincerely apologize for your disappointing experience. We have forwarded your feedback to the relevant team for immediate action. We will contact you within 48 hours with an update on the improvements being made.`;\r\n    }\r\n    \r\n    return `Thank you for your valuable feedback. We appreciate you taking the time to share your experience with us.`;\r\n  }\r\n}\r\n\r\n// Advanced AI-powered feedback analysis\r\nasync function analyzeAdvancedFeedback(\r\n  textFeedback?: string,\r\n  voiceBlob?: Blob,\r\n  imageBlob?: Blob,\r\n  language: string = 'auto'\r\n): Promise<{\r\n  aiAnalysis?: AIAnalysisResult\r\n  voiceAnalysis?: VoiceAnalysisResult\r\n  imageAnalysis?: ImageAnalysisResult\r\n}> {\r\n  try {\r\n    const results: any = {}\r\n\r\n    // Analyze text if provided\r\n    if (textFeedback) {\r\n      results.aiAnalysis = await aiService.analyzeText(textFeedback, language)\r\n    }\r\n\r\n    // Analyze voice if provided\r\n    if (voiceBlob) {\r\n      results.voiceAnalysis = await aiService.analyzeVoice(voiceBlob)\r\n      \r\n      // If no text feedback, use voice transcription for text analysis\r\n      if (!textFeedback && results.voiceAnalysis.transcription) {\r\n        results.aiAnalysis = await aiService.analyzeText(results.voiceAnalysis.transcription, language)\r\n      }\r\n    }\r\n\r\n    // Analyze image if provided\r\n    if (imageBlob) {\r\n      results.imageAnalysis = await aiService.analyzeImage(imageBlob)\r\n    }\r\n\r\n    return results\r\n  } catch (error) {\r\n    console.error('Advanced feedback analysis failed:', error)\r\n    \r\n    // Fallback analysis\r\n    if (textFeedback) {\r\n      return {\r\n        aiAnalysis: await aiService.analyzeText(textFeedback, language)\r\n      }\r\n    }\r\n    \r\n    throw error\r\n  }\r\n}\r\n\r\n// Real-time sentiment monitoring\r\nclass SentimentMonitor {\r\n  private static sentimentHistory: Array<{\r\n    timestamp: string\r\n    sentiment: string\r\n    confidence: number\r\n    location: string\r\n    category: string\r\n  }> = []\r\n\r\n  static addSentiment(feedback: EnhancedFeedback) {\r\n    this.sentimentHistory.push({\r\n      timestamp: feedback.timestamp,\r\n      sentiment: feedback.aiAnalysis.sentiment,\r\n      confidence: feedback.aiAnalysis.confidence,\r\n      location: feedback.location,\r\n      category: feedback.category\r\n    })\r\n\r\n    // Keep only last 1000 entries\r\n    if (this.sentimentHistory.length > 1000) {\r\n      this.sentimentHistory = this.sentimentHistory.slice(-1000)\r\n    }\r\n\r\n    // Check for sentiment trends\r\n    this.checkSentimentTrends(feedback.location, feedback.category)\r\n  }\r\n\r\n  static checkSentimentTrends(location: string, category: string) {\r\n    const recentFeedbacks = this.sentimentHistory\r\n      .filter(s => s.location === location && s.category === category)\r\n      .slice(-10) // Last 10 feedbacks for this location/category\r\n\r\n    if (recentFeedbacks.length >= 5) {\r\n      const negativeFeedbacks = recentFeedbacks.filter(s => s.sentiment === 'negative')\r\n      \r\n      if (negativeFeedbacks.length >= 3) {\r\n        console.log(`âš ï¸ TREND ALERT: Increasing negative sentiment detected for ${location} - ${category}`)\r\n        // In production, this would trigger notifications to tourism officials\r\n      }\r\n    }\r\n  }\r\n\r\n  static getSentimentTrends(location?: string, category?: string) {\r\n    let filtered = this.sentimentHistory\r\n    \r\n    if (location) {\r\n      filtered = filtered.filter(s => s.location === location)\r\n    }\r\n    \r\n    if (category) {\r\n      filtered = filtered.filter(s => s.category === category)\r\n    }\r\n    \r\n    return filtered.slice(-30) // Last 30 entries\r\n  }\r\n}\r\n\r\n// AI-powered chatbot for instant responses\r\nclass FeedbackChatbot {\r\n  static async generateResponse(feedback: EnhancedFeedback): Promise<string> {\r\n    const { aiAnalysis, location, category } = feedback\r\n    \r\n    // Generate contextual response based on AI analysis\r\n    if (aiAnalysis.urgency === 'critical') {\r\n      return `Thank you for this critical feedback about ${location}. We are immediately addressing the ${aiAnalysis.categories?.join(', ')} issues you've mentioned. A senior official will contact you within 2 hours.`\r\n    }\r\n    \r\n    if (aiAnalysis.sentiment === 'positive') {\r\n      return `We're delighted to hear about your positive experience at ${location}! Thank you for highlighting ${aiAnalysis.keywords.slice(0, 3).join(', ')}. We'll share your feedback with our team.`\r\n    }\r\n    \r\n    if (aiAnalysis.sentiment === 'negative') {\r\n      const issues = aiAnalysis.actionableInsights?.slice(0, 2).join(' and ') || 'the issues you mentioned'\r\n      return `We sincerely apologize for your experience at ${location}. We're taking immediate action on ${issues}. You can expect an update within 24-48 hours.`\r\n    }\r\n    \r\n    return `Thank you for your feedback about ${location}. Your insights about ${category.toLowerCase()} are valuable for improving our tourism services.`\r\n  }\r\n  \r\n  static async generateFollowUpQuestions(feedback: EnhancedFeedback): Promise<string[]> {\r\n    const questions: string[] = []\r\n    \r\n    if (feedback.aiAnalysis.sentiment === 'negative') {\r\n      questions.push('What specific steps would you like to see implemented to improve this experience?')\r\n      questions.push('Would you be willing to revisit this location if improvements were made?')\r\n    }\r\n    \r\n    if (feedback.aiAnalysis.categories?.includes('service quality')) {\r\n      questions.push('Can you provide more details about the staff interaction?')\r\n    }\r\n    \r\n    if (feedback.aiAnalysis.categories?.includes('cleanliness')) {\r\n      questions.push('Which specific areas need attention regarding cleanliness?')\r\n    }\r\n    \r\n    return questions.slice(0, 3)\r\n  }\r\n}\r\n\r\n// Fallback rule-based sentiment analysis\r\nfunction fallbackSentimentAnalysis(text: string, language: string): {\r\n  sentiment: 'positive' | 'negative' | 'neutral'\r\n  confidence: number\r\n  emotions: { [key: string]: number }\r\n  keywords: string[]\r\n} {\r\n  const positiveWords = ['good', 'great', 'excellent', 'amazing', 'wonderful', 'beautiful', 'love', 'perfect', 'awesome', 'fantastic']\r\n  const negativeWords = ['bad', 'terrible', 'awful', 'horrible', 'hate', 'worst', 'disappointing', 'poor', 'dirty', 'unsafe']\r\n  \r\n  // Hindi positive/negative words\r\n  const hindiPositive = ['à¤…à¤šà¥à¤›à¤¾', 'à¤¬à¤¹à¥à¤¤', 'à¤¸à¥à¤‚à¤¦à¤°', 'à¤–à¥à¤¶', 'à¤ªà¥à¤°à¤¸à¤¨à¥à¤¨', 'à¤‰à¤¤à¥à¤•à¥ƒà¤·à¥à¤Ÿ']\r\n  const hindiNegative = ['à¤¬à¥à¤°à¤¾', 'à¤—à¤‚à¤¦à¤¾', 'à¤–à¤°à¤¾à¤¬', 'à¤¦à¥à¤–à¥€', 'à¤¨à¤¿à¤°à¤¾à¤¶']\r\n\r\n  const words = text.toLowerCase().split(/\\s+/)\r\n  let positiveCount = 0\r\n  let negativeCount = 0\r\n  let keywords: string[] = []\r\n\r\n  words.forEach(word => {\r\n    if (positiveWords.includes(word) || hindiPositive.includes(word)) {\r\n      positiveCount++\r\n      keywords.push(word)\r\n    }\r\n    if (negativeWords.includes(word) || hindiNegative.includes(word)) {\r\n      negativeCount++\r\n      keywords.push(word)\r\n    }\r\n  })\r\n\r\n  let sentiment: 'positive' | 'negative' | 'neutral' = 'neutral'\r\n  let confidence = 0.5\r\n\r\n  if (positiveCount > negativeCount) {\r\n    sentiment = 'positive'\r\n    confidence = Math.min(0.9, 0.5 + (positiveCount - negativeCount) * 0.1)\r\n  } else if (negativeCount > positiveCount) {\r\n    sentiment = 'negative'\r\n    confidence = Math.min(0.9, 0.5 + (negativeCount - positiveCount) * 0.1)\r\n  }\r\n\r\n  const emotions = {\r\n    joy: sentiment === 'positive' ? confidence * 0.8 : 0.1,\r\n    anger: sentiment === 'negative' ? confidence * 0.6 : 0.1,\r\n    sadness: sentiment === 'negative' ? confidence * 0.4 : 0.1,\r\n    surprise: 0.2,\r\n    fear: sentiment === 'negative' ? confidence * 0.3 : 0.05,\r\n    disgust: sentiment === 'negative' ? confidence * 0.2 : 0.05\r\n  }\r\n\r\n  return {\r\n    sentiment,\r\n    confidence,\r\n    emotions,\r\n    keywords: keywords.slice(0, 5)\r\n  }\r\n}\r\n\r\n// Enhanced feedback database with AI analysis\r\nlet feedbacks: EnhancedFeedback[] = []\r\n\r\nexport async function GET(request: NextRequest) {\r\n  try {\r\n    const { searchParams } = new URL(request.url)\r\n    const location = searchParams.get('location')\r\n    const category = searchParams.get('category')\r\n    const sentiment = searchParams.get('sentiment')\r\n    const flagged = searchParams.get('flagged')\r\n    const urgency = searchParams.get('urgency')\r\n    const limit = parseInt(searchParams.get('limit') || '50')\r\n    const offset = parseInt(searchParams.get('offset') || '0')\r\n\r\n    let filteredFeedbacks = [...feedbacks]\r\n\r\n    if (location && location !== 'All') {\r\n      filteredFeedbacks = filteredFeedbacks.filter(f => f.location === location)\r\n    }\r\n\r\n    if (category && category !== 'All') {\r\n      filteredFeedbacks = filteredFeedbacks.filter(f => f.category === category)\r\n    }\r\n\r\n    if (sentiment && sentiment !== 'All') {\r\n      filteredFeedbacks = filteredFeedbacks.filter(f => f.aiAnalysis.sentiment === sentiment)\r\n    }\r\n\r\n    if (flagged === 'true') {\r\n      filteredFeedbacks = filteredFeedbacks.filter(f => f.flagged)\r\n    }\r\n\r\n    if (urgency && urgency !== 'All') {\r\n      filteredFeedbacks = filteredFeedbacks.filter(f => f.urgencyLevel === urgency)\r\n    }\r\n\r\n    // Sort by timestamp (newest first)\r\n    filteredFeedbacks.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())\r\n\r\n    const paginatedFeedbacks = filteredFeedbacks.slice(offset, offset + limit)\r\n\r\n    // Calculate sentiment statistics\r\n    const sentimentStats = {\r\n      positive: filteredFeedbacks.filter(f => f.aiAnalysis.sentiment === 'positive').length,\r\n      negative: filteredFeedbacks.filter(f => f.aiAnalysis.sentiment === 'negative').length,\r\n      neutral: filteredFeedbacks.filter(f => f.aiAnalysis.sentiment === 'neutral').length,\r\n      total: filteredFeedbacks.length\r\n    }\r\n\r\n    // Calculate urgency statistics\r\n    const urgencyStats = {\r\n      critical: filteredFeedbacks.filter(f => f.urgencyLevel === 'critical').length,\r\n      high: filteredFeedbacks.filter(f => f.urgencyLevel === 'high').length,\r\n      medium: filteredFeedbacks.filter(f => f.urgencyLevel === 'medium').length,\r\n      low: filteredFeedbacks.filter(f => f.urgencyLevel === 'low').length\r\n    }\r\n\r\n    // Get sentiment trends\r\n    const sentimentTrends = SentimentMonitor.getSentimentTrends(location || undefined, category || undefined)\r\n\r\n    return NextResponse.json({\r\n      feedbacks: paginatedFeedbacks,\r\n      total: filteredFeedbacks.length,\r\n      sentimentStats,\r\n      urgencyStats,\r\n      sentimentTrends,\r\n      hasMore: offset + limit < filteredFeedbacks.length\r\n    })\r\n  } catch (error) {\r\n    return NextResponse.json({ error: 'Failed to fetch feedback' }, { status: 500 })\r\n  }\r\n}\r\n\r\nexport async function POST(request: NextRequest) {\r\n  try {\r\n    const body = await request.json()\r\n    const { userId, userName, location, category, rating, textFeedback, language = 'auto', voiceData, imageData, emojiRating } = body\r\n\r\n    // Advanced AI analysis\r\n    let aiAnalysis: AIAnalysisResult\r\n    let voiceAnalysis: VoiceAnalysisResult | undefined\r\n    let imageAnalysis: ImageAnalysisResult | undefined\r\n\r\n    try {\r\n      // Convert base64 data to blobs if provided\r\n      const voiceBlob = voiceData ? new Blob([Buffer.from(voiceData, 'base64')], { type: 'audio/wav' }) : undefined\r\n      const imageBlob = imageData ? new Blob([Buffer.from(imageData, 'base64')], { type: 'image/jpeg' }) : undefined\r\n\r\n      const analysisResults = await analyzeAdvancedFeedback(textFeedback, voiceBlob, imageBlob, language)\r\n      aiAnalysis = analysisResults.aiAnalysis!\r\n      voiceAnalysis = analysisResults.voiceAnalysis\r\n      imageAnalysis = analysisResults.imageAnalysis\r\n    } catch (error) {\r\n      console.error('AI analysis failed, using fallback:', error)\r\n      // Fallback to basic analysis\r\n      aiAnalysis = {\r\n        sentiment: 'neutral',\r\n        confidence: 0.5,\r\n        emotions: {},\r\n        keywords: [],\r\n        language: language || 'en',\r\n        toxicity: 0,\r\n        urgency: 'low',\r\n        categories: [],\r\n        actionableInsights: []\r\n      }\r\n    }\r\n\r\n    // Determine urgency level\r\n    const urgencyLevel = aiAnalysis.urgency || 'low'\r\n\r\n    // Check for flagging conditions\r\n    const flagged = (aiAnalysis.sentiment === 'negative' && aiAnalysis.confidence > 0.7) ||\r\n                   (aiAnalysis.toxicity && aiAnalysis.toxicity > 0.5) ||\r\n                   urgencyLevel === 'critical' || urgencyLevel === 'high'\r\n\r\n    const newFeedback: EnhancedFeedback = {\r\n      id: feedbacks.length + 1,\r\n      userId,\r\n      userName,\r\n      location,\r\n      category,\r\n      rating,\r\n      textFeedback,\r\n      language: aiAnalysis.language,\r\n      voiceData,\r\n      imageData,\r\n      emojiRating,\r\n      aiAnalysis,\r\n      voiceAnalysis,\r\n      imageAnalysis,\r\n      timestamp: new Date().toISOString(),\r\n      isVerified: false,\r\n      responseFromVendor: undefined,\r\n      flagged,\r\n      urgencyLevel\r\n    }\r\n\r\n    // Generate auto-response using AI chatbot\r\n    try {\r\n      newFeedback.autoResponseGenerated = await FeedbackChatbot.generateResponse(newFeedback)\r\n    } catch (error) {\r\n      console.error('Auto-response generation failed:', error)\r\n    }\r\n\r\n    feedbacks.push(newFeedback)\r\n\r\n    // Add to sentiment monitoring\r\n    SentimentMonitor.addSentiment(newFeedback)\r\n\r\n    // Trigger alerts for critical issues\r\n    await AlertSystem.triggerAlert(newFeedback)\r\n\r\n    return NextResponse.json({\r\n      ...newFeedback,\r\n      followUpQuestions: await FeedbackChatbot.generateFollowUpQuestions(newFeedback)\r\n    }, { status: 201 })\r\n  } catch (error) {\r\n    console.error('Failed to submit feedback:', error)\r\n    return NextResponse.json({ error: 'Failed to submit feedback' }, { status: 500 })\r\n  }\r\n}\r\n\r\nexport async function PUT(request: NextRequest) {\r\n  try {\r\n    const body = await request.json()\r\n    const { feedbackId, responseFromVendor, flagged } = body\r\n\r\n    const feedbackIndex = feedbacks.findIndex(f => f.id === feedbackId)\r\n    if (feedbackIndex === -1) {\r\n      return NextResponse.json({ error: 'Feedback not found' }, { status: 404 })\r\n    }\r\n\r\n    feedbacks[feedbackIndex] = {\r\n      ...feedbacks[feedbackIndex],\r\n      ...(responseFromVendor && { responseFromVendor }),\r\n      ...(typeof flagged === 'boolean' && { flagged }),\r\n      updatedAt: new Date().toISOString()\r\n    }\r\n\r\n    return NextResponse.json(feedbacks[feedbackIndex])\r\n  } catch (error) {\r\n    return NextResponse.json({ error: 'Failed to update feedback' }, { status: 500 })\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 970, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}